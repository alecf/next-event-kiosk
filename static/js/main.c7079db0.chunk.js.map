{"version":3,"sources":["useAnimationFrame.ts","retry.tsx","useLoadCalendarApi.tsx","App.tsx","usePersistentState.ts","useWhyDidYouUpdate.ts","serviceWorker.ts","index.tsx","App.module.css"],"names":["useAnimationFrame","interval","callback","cc","useRef","intervalRef","doSomething","useCallback","timestamp","current","undefined","setTimeout","requestAnimationFrame","console","log","useEffect","cancelAnimationFrame","retry","fn","timeoutMs","maxAttempts","attempts","Promise","resolve","reject","loaded","tryload","ex","Error","initGoogleCalendar","apiKey","clientId","attempt","a","gapi","load","loadCalendarApi","retries","i","error","timeout","retryTime","client","init","discoveryDocs","scope","calendarScope","calendar","process","REACT_APP_CLIENT_ID","App","useState","window","localStorage","getItem","gapiToken","setGapiToken","setError","user","setUser","calendars","setCalendars","gLoginLoaded","setGLoginLoaded","loginRenderKey","setLoginRenderKey","setLoginState","Math","random","useRetryLogin","haveCalendarApi","setHaveCalendarApi","refresh","useLoadCalendarApi","onSuccess","response","tokenId","setItem","profileObj","onFailure","key","value","item","itemValue","JSON","parse","state","setState","stringify","usePersistentState","events","setEvents","onLogout","removeItem","onLoadCalendar","calendarList","list","result","loadEvents","calendarId","makeCalendarListQuery","calendarEvents","time","loadTime","setTime","Date","useCurrentTime","useMemo","now","toISOString","futureEvents","items","map","event","start","end","dateTime","eventStart","startDateTime","eventEnd","endDateTime","getDay","happeningNow","pending","secondsLeftStart","floor","valueOf","secondsLeftEnd","ago","filter","notEmpty","_","partition","future","slice","extractEvents","name","props","previousProps","allKeys","Object","keys","changesObj","forEach","from","to","length","useWhyDidYouUpdate","className","styles","app","header","toLocaleTimeString","style","fontSize","id","onClick","summary","timeHeader","buttonText","isSignedIn","uxMode","onLogoutSuccess","disabled","EventBanner","soon","ONE_MINUTE","imminent","colorClass","classNames","banner","format","left","data-secondsLeft","data-minutesLeft","note","timeMin","showDeleted","singleEvents","maxResults","orderBy","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message","module","exports"],"mappings":"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","file":"static/js/main.c7079db0.chunk.js","sourcesContent":["import { useEffect, useRef, useCallback } from 'react';\n\n/** Run a callback repeatedly at the given interval. Set interval to 0 to stop */\nexport function useAnimationFrame(\n  interval: number,\n  callback: (timestamp: number) => void\n) {\n  const cc = useRef<number>();\n  const intervalRef = useRef<number>(interval);\n  const doSomething = useCallback(\n    (timestamp: number) => {\n      if (intervalRef.current === 0) {\n        console.log('all done, interval is 0', intervalRef.current);\n        return;\n      }\n      callback(timestamp);\n      cc.current = undefined;\n      setTimeout(() => {\n        cc.current = requestAnimationFrame(doSomething);\n      }, intervalRef.current);\n    },\n    [callback]\n  );\n  useEffect(() => {\n    intervalRef.current = interval;\n  }, [interval]);\n  useEffect(() => {\n    cc.current = requestAnimationFrame(doSomething);\n\n    return () => {\n      if (cc.current) {\n        cancelAnimationFrame(cc.current);\n      }\n    };\n  }, [doSomething]);\n}\n","/** Keep retrying a function until it returns true */\nexport function retry(fn: () => boolean, timeoutMs = 1000, maxAttempts = 0) {\n  let attempts = 0;\n  return new Promise((resolve, reject) => {\n    let loaded = false;\n    function tryload() {\n      attempts += 1;\n      try {\n        loaded = fn();\n      } catch (ex) {\n        reject(ex);\n      }\n      if (loaded) {\n        resolve();\n        return;\n      }\n      console.log('not loaded...waiting', timeoutMs);\n      if (maxAttempts && attempts > maxAttempts) {\n        reject(new Error(`Retried ${attempts} times`));\n        return;\n      }\n      setTimeout(tryload, timeoutMs);\n    }\n    tryload();\n  });\n}\n","import { useEffect, useState } from 'react';\n\nimport { calendarScope } from './App';\nimport { retry } from './retry';\n\nexport function useLoadCalendarApi(\n  apiKey: string,\n  clientId: string,\n  user: any\n) {\n  const [haveCalendarApi, setHaveCalendarApi] = useState(false);\n\n  useEffect(() => {\n    async function refresh() {\n      try {\n        console.log('loading calendar for ', user);\n        await initGoogleCalendar(apiKey, clientId);\n        console.log('have calendar');\n        setHaveCalendarApi(true);\n      } catch (ex) {\n        console.log('failed to get calendar');\n      }\n    }\n    if (user && clientId) {\n      refresh();\n    }\n  }, [apiKey, clientId, setHaveCalendarApi, user]);\n\n  return haveCalendarApi;\n}\n/** Try multiple times to load the calendar */\n\nasync function initGoogleCalendar(\n  apiKey: string,\n  clientId: string,\n  retries = 5\n) {\n  function attempt() {\n    return new Promise((resolve, reject) => {\n      gapi.load('client', () => resolve(loadCalendarApi(apiKey, clientId)));\n    });\n  }\n\n  for (let i = 0; i < retries; i++) {\n    try {\n      console.log('loading calendar..');\n      await attempt();\n      return;\n    } catch (ex) {\n      console.error(\n        `Attempt ${i + 1} of ${retries}: failed to load calendar: `,\n        ex\n      );\n      // continue in the loop\n    }\n  }\n}\n/** Try once to load the calendar API with a timeout - rejects if the calendar fails to load */\nfunction loadCalendarApi(apiKey: string, clientId: string, timeout = 2000) {\n  const retryTime = 200;\n  return new Promise(async (resolve, reject) => {\n    try {\n      gapi.client.init({\n        apiKey,\n        clientId,\n        discoveryDocs: [\n          'https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest',\n        ],\n        scope: calendarScope,\n      });\n      // wait up to `timeout` seconds for the calendar to show up\n      await retry(() => !!gapi.client.calendar, 200, timeout / retryTime);\n      console.log('have calendar api');\n      resolve(null);\n    } catch (ex) {\n      console.error('Error loading calendar', ex);\n      reject(ex);\n    }\n  });\n}\n","import classNames from 'classnames';\nimport { format } from 'date-fns';\nimport _ from 'lodash';\nimport React, {\n  Fragment,\n  FunctionComponent,\n  useCallback,\n  useMemo,\n  useState,\n} from 'react';\nimport GoogleLogin, {\n  GoogleLoginResponse,\n  GoogleLoginResponseOffline,\n  GoogleLogout,\n} from 'react-google-login';\nimport ago from 's-ago';\n\nimport styles from './App.module.css';\nimport { useAnimationFrame } from './useAnimationFrame';\nimport { useLoadCalendarApi } from './useLoadCalendarApi';\nimport { usePersistentState } from './usePersistentState';\nimport { useWhyDidYouUpdate } from './useWhyDidYouUpdate';\n\nconst clientId = process.env.REACT_APP_CLIENT_ID ?? '';\nconst apiKey = 'AIzaSyD01PlE0xERSwpZQauir8ZisF5e7LuNAbo';\nconst ONE_MINUTE = 60;\nconst ONE_HOUR = ONE_MINUTE * 60;\n\nexport const calendarScope =\n  'https://www.googleapis.com/auth/calendar.events.readonly https://www.googleapis.com/auth/calendar.readonly';\n\ninterface CustomEvent extends gapi.client.calendar.Event {\n  happeningNow: boolean;\n  pending: boolean;\n  secondsLeftStart: number;\n  secondsLeftEnd: number;\n  ago: string;\n}\n\nconst App: FunctionComponent = () => {\n  const [gapiToken, setGapiToken] = useState(\n    window.localStorage.getItem('gapi_token')\n  );\n  const [error, setError] = useState<Error | null>();\n  const [user, setUser] = useState<any>();\n  const [\n    calendars,\n    setCalendars,\n  ] = useState<gapi.client.calendar.CalendarList | null>();\n\n  const { loginRenderKey, setGLoginLoaded } = useRetryLogin();\n  const haveCalendarApi = useLoadCalendarApi(apiKey, clientId, user);\n\n  const onSuccess = useCallback(\n    (response: GoogleLoginResponse | GoogleLoginResponseOffline) => {\n      console.log(\n        'onSuccess',\n        'tokenId' in response ? response.tokenId : response\n      );\n      setGLoginLoaded(true);\n      if (!('tokenId' in response)) {\n        return;\n      }\n      console.log('response: ', response);\n      window.localStorage.setItem('gapi_token', response.tokenId);\n      setUser(response.profileObj);\n    },\n    [setGLoginLoaded]\n  );\n\n  const onFailure = useCallback(\n    (response) => {\n      setGLoginLoaded(true);\n      console.log('failure: ', response);\n      setError(response);\n    },\n    [setGLoginLoaded]\n  );\n  const [\n    events,\n    setEvents,\n  ] = usePersistentState<gapi.client.calendar.Events | null>(\n    'current_events',\n    null\n  );\n\n  const onLogout = useCallback(() => {\n    setGapiToken(null);\n    setUser(null);\n    window.localStorage.removeItem('gapi_token');\n  }, []);\n  const onLoadCalendar = useCallback(async () => {\n    const calendars = await gapi.client.calendar.calendarList.list();\n    setCalendars(calendars.result);\n  }, []);\n\n  const loadEvents = useCallback(\n    async (calendarId: string) => {\n      const calendarEvents = await gapi.client.calendar.events.list(\n        makeCalendarListQuery(calendarId)\n      );\n      setEvents(calendarEvents.result);\n      setCalendars(null);\n    },\n    [setEvents]\n  );\n\n  const time = useCurrentTime();\n\n  const { current, future } = useMemo(() => {\n    return extractEvents(time, events);\n  }, [events, time]);\n  useWhyDidYouUpdate('GoogleLogin', {\n    key: loginRenderKey,\n    clientId: clientId,\n    onSuccess: onSuccess,\n    onFailure: onFailure,\n    scope: calendarScope,\n  });\n\n  return (\n    <div className={styles.app}>\n      <header className={styles.header}>\n        <h1 className={styles.time}>{time?.toLocaleTimeString()}</h1>\n        {error && (\n          <div>\n            Error:{' '}\n            <pre style={{ fontSize: '12px' }}>{JSON.stringify(error)}</pre>\n          </div>\n        )}\n        {calendars && (\n          <ul>\n            {calendars.items?.map((calendar) => (\n              <li key={calendar.id}>\n                <button onClick={() => loadEvents(calendar.id ?? '')}>\n                  {calendar.summary}\n                </button>\n              </li>\n            ))}\n          </ul>\n        )}\n        {!!current?.length && (\n          <div>\n            <h2 className={styles.timeHeader}>Right now</h2>\n\n            <ul>\n              {current.map((event) => (\n                <EventBanner key={event.id} event={event} />\n              ))}\n            </ul>\n          </div>\n        )}\n        {!!future?.length && (\n          <div>\n            <h2 className={styles.timeHeader}>Coming up</h2>\n            <ul>\n              {future.map((event) => (\n                <EventBanner key={event.id} event={event} />\n              ))}\n            </ul>\n          </div>\n        )}\n        <div>\n          {user && <div>User: {user.name}</div>}\n          <GoogleLogin\n            key={loginRenderKey}\n            clientId={clientId}\n            buttonText=\"Login\"\n            onSuccess={onSuccess}\n            onFailure={onFailure}\n            isSignedIn\n            uxMode=\"redirect\"\n            scope={calendarScope}\n          />\n          {gapiToken && (\n            <GoogleLogout clientId={clientId} onLogoutSuccess={onLogout} />\n          )}\n          <button onClick={onLoadCalendar} disabled={!haveCalendarApi}>\n            Load calendar\n          </button>\n        </div>\n      </header>\n    </div>\n  );\n};\n\nexport default App;\n\nconst loadTime = new Date();\nconst EventBanner: FunctionComponent<{ event: CustomEvent }> = ({ event }) => {\n  const soon = event.secondsLeftStart < ONE_HOUR;\n  const imminent = event.secondsLeftStart < 5 * ONE_MINUTE;\n  const colorClass = classNames(\n    {\n      [styles.now]: event.happeningNow,\n      [styles.soon]: soon && !imminent,\n      [styles.imminent]: imminent,\n    },\n    styles.banner\n  );\n\n  const start = format(new Date(event.start?.dateTime ?? ''), 'h:mm');\n  const left = ago(new Date(event.end?.dateTime ?? ''));\n  return (\n    <li\n      key={event.id}\n      className={colorClass}\n      data-secondsLeft={event.secondsLeftStart}\n      data-minutesLeft={event.secondsLeftStart / 60}\n    >\n      {event.summary} {event.pending ? event.ago : null}\n      {event.pending && (\n        <Fragment>\n          {` @`}&nbsp;{start}\n        </Fragment>\n      )}\n      <div className={styles.note}>\n        {event.happeningNow && ` ending ${left}`}\n      </div>\n    </li>\n  );\n};\n\nfunction extractEvents(time: Date, events: gapi.client.calendar.Events | null) {\n  const now = time.toISOString();\n\n  const futureEvents =\n    events?.items\n      ?.map((event): CustomEvent | null => {\n        const { start, end } = event;\n        // We dont support all-day events yet\n        if (!start?.dateTime) {\n          return null;\n        }\n        const eventStart = new Date(start.dateTime);\n        const startDateTime = eventStart.toISOString();\n        const eventEnd = new Date(end?.dateTime ?? '');\n        const endDateTime = eventEnd.toISOString();\n\n        const ended = now > endDateTime;\n        if (ended || eventStart.getDay() !== time.getDay()) {\n          return null;\n        }\n\n        const happeningNow = startDateTime <= now && now < endDateTime;\n        const pending = !happeningNow ? endDateTime > now : false;\n\n        const secondsLeftStart = Math.floor(\n          (eventStart.valueOf() - time.valueOf()) / 1000\n        );\n        const secondsLeftEnd = Math.floor(\n          (eventEnd.valueOf() - time.valueOf()) / 1000\n        );\n\n        return {\n          ...event,\n          happeningNow,\n          pending,\n          secondsLeftStart,\n          secondsLeftEnd,\n          ago: ago(eventStart),\n        };\n      })\n      .filter(notEmpty) ?? [];\n  const [current, future] = _.partition(\n    futureEvents,\n    (event) => event.happeningNow\n  );\n  // console.log('current = ', current);\n  // console.log('future = ', future);\n  return { current, future: future.slice(0, 3) };\n}\n\nfunction useCurrentTime() {\n  const [time, setTime] = useState<Date>(loadTime);\n  const onFrame = useCallback(() => {\n    setTime(new Date());\n  }, []);\n  useAnimationFrame(1000, onFrame);\n  return time;\n}\n\nfunction makeCalendarListQuery(calendarId: string) {\n  console.log('filtering by ', new Date().toISOString());\n  return {\n    calendarId,\n    timeMin: new Date().toISOString(),\n    showDeleted: false,\n    singleEvents: true,\n    maxResults: 10,\n    orderBy: 'startTime',\n  };\n}\nfunction notEmpty<TValue>(value: TValue | null | undefined): value is TValue {\n  return value !== null && value !== undefined;\n}\n\nfunction useRetryLogin() {\n  const [gLoginLoaded, setGLoginLoaded] = useState(false);\n  const [loginRenderKey, setLoginRenderKey] = useState('start');\n  const setLoginState = useCallback(() => {\n    if (!gLoginLoaded) {\n      setLoginRenderKey(`key-${Math.random()}`);\n    }\n  }, [gLoginLoaded]);\n  useAnimationFrame(gLoginLoaded ? 0 : 3000, setLoginState);\n  return { setGLoginLoaded, loginRenderKey };\n}\n","import { useState, useCallback } from 'react';\nexport function usePersistentState<T>(\n  key: string,\n  value: T\n): [T, (value: T) => void] {\n  const item = window.localStorage.getItem(key);\n  const itemValue = item !== null ? JSON.parse(item) : value;\n  const [state, setState] = useState<T>(itemValue);\n\n  const setStatePersistently = useCallback(\n    (value: T) => {\n      setState(value);\n      window.localStorage.setItem(key, JSON.stringify(value));\n    },\n    [key]\n  );\n  return [state, setStatePersistently];\n}\n","import { useEffect, useRef } from 'react';\nexport function useWhyDidYouUpdate<T extends object>(name: string, props: T) {\n  // Get a mutable ref object where we can store props ...\n  // ... for comparison next time this hook runs.\n  const previousProps = useRef<Partial<T>>({});\n\n  useEffect(() => {\n    if (previousProps.current) {\n      // Get all keys from previous and current props\n      const allKeys: (keyof T)[] = Object.keys({\n        ...previousProps.current,\n        ...props,\n      }) as (keyof T)[];\n      // Use this object to keep track of changed props\n      const changesObj: any = {};\n      // Iterate through keys\n      allKeys.forEach((key) => {\n        // If previous is different from current\n        if (previousProps.current[key] !== props[key]) {\n          // Add to changesObj\n          changesObj[key] = {\n            from: previousProps.current[key],\n            to: props[key],\n          };\n        }\n      });\n\n      // If changesObj not empty then output to console\n      if (Object.keys(changesObj).length) {\n        console.log('[why-did-you-update]', name, changesObj);\n      }\n    }\n\n    // Finally update previousProps with current props for next hook call\n    previousProps.current = props;\n  });\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"app\":\"App_app__1kX79\",\"logo\":\"App_logo__1ItuU\",\"time\":\"App_time__Mwxyj\",\"header\":\"App_header__3ZZ1n\",\"link\":\"App_link__TB6Cl\",\"banner\":\"App_banner__29E-O\",\"soon\":\"App_soon__1HASJ\",\"imminent\":\"App_imminent__3j97Z\",\"now\":\"App_now__19jbL\",\"timeHeader\":\"App_timeHeader__3vLT2\",\"note\":\"App_note__3pgJB\",\"App-logo-spin\":\"App_App-logo-spin__1e7sv\"};"],"sourceRoot":""}