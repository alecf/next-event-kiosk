{"version":3,"sources":["useAnimationFrame.ts","retry.tsx","useLoadCalendarApi.tsx","usePersistentState.ts","useTimeout.tsx","App.tsx","serviceWorker.ts","index.tsx","App.module.css"],"names":["useAnimationFrame","interval","callback","cc","useRef","intervalRef","doSomething","useCallback","timestamp","current","undefined","setTimeout","requestAnimationFrame","console","log","useEffect","cancelAnimationFrame","retry","fn","timeoutMs","maxAttempts","attempts","Promise","resolve","reject","loaded","tryload","ex","Error","initGoogleCalendar","apiKey","clientId","attempt","a","gapi","load","loadCalendarApi","retries","i","error","timeout","retryTime","client","init","discoveryDocs","scope","calendarScope","calendar","usePersistentState","key","value","item","window","localStorage","getItem","itemValue","JSON","parse","useState","state","setState","setItem","stringify","process","App","gapiToken","setGapiToken","setError","user","setUser","calendars","setCalendars","gLoginLoaded","setGLoginLoaded","loginRenderKey","setLoginRenderKey","setLoginState","Math","random","useRetryLogin","haveCalendarApi","setHaveCalendarApi","refresh","useLoadCalendarApi","onSuccess","response","tokenId","profileObj","onFailure","events","setEvents","calendarId","setCalendarId","onLogout","removeItem","onLoadCalendar","calendarList","list","result","loadEvents","makeCalendarListQuery","calendarEvents","timeoutIdRef","cancel","timeoutId","clearTimeout","useTimeout","ONE_MINUTE","time","loadTime","setTime","Date","useCurrentTime","useMemo","now","toISOString","futureEvents","items","map","event","start","end","dateTime","eventStart","startDateTime","eventEnd","endDateTime","getDay","happeningNow","pending","secondsLeftStart","floor","valueOf","secondsLeftEnd","ago","filter","notEmpty","_","partition","future","slice","extractEvents","className","styles","app","header","toLocaleTimeString","style","fontSize","id","onClick","summary","length","timeHeader","name","buttonText","isSignedIn","uxMode","onLogoutSuccess","disabled","EventBanner","soon","imminent","colorClass","classNames","banner","format","left","data-secondsLeft","data-minutesLeft","note","timeMin","showDeleted","singleEvents","maxResults","orderBy","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message","module","exports"],"mappings":"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","file":"static/js/main.af436dc9.chunk.js","sourcesContent":["import { useEffect, useRef, useCallback } from 'react';\n\n/** Run a callback repeatedly at the given interval. Set interval to 0 to stop */\nexport function useAnimationFrame(\n  interval: number,\n  callback: (timestamp: number) => void\n) {\n  const cc = useRef<number>();\n  const intervalRef = useRef<number>(interval);\n  const doSomething = useCallback(\n    (timestamp: number) => {\n      if (intervalRef.current === 0) {\n        console.log('all done, interval is 0', intervalRef.current);\n        return;\n      }\n      callback(timestamp);\n      cc.current = undefined;\n      setTimeout(() => {\n        cc.current = requestAnimationFrame(doSomething);\n      }, intervalRef.current);\n    },\n    [callback]\n  );\n  useEffect(() => {\n    intervalRef.current = interval;\n  }, [interval]);\n  useEffect(() => {\n    cc.current = requestAnimationFrame(doSomething);\n\n    return () => {\n      if (cc.current) {\n        cancelAnimationFrame(cc.current);\n      }\n    };\n  }, [doSomething]);\n}\n","/** Keep retrying a function until it returns true */\nexport function retry(fn: () => boolean, timeoutMs = 1000, maxAttempts = 0) {\n  let attempts = 0;\n  return new Promise((resolve, reject) => {\n    let loaded = false;\n    function tryload() {\n      attempts += 1;\n      try {\n        loaded = fn();\n      } catch (ex) {\n        reject(ex);\n      }\n      if (loaded) {\n        resolve();\n        return;\n      }\n      console.log('not loaded...waiting', timeoutMs);\n      if (maxAttempts && attempts > maxAttempts) {\n        reject(new Error(`Retried ${attempts} times`));\n        return;\n      }\n      setTimeout(tryload, timeoutMs);\n    }\n    tryload();\n  });\n}\n","import { useEffect, useState } from 'react';\n\nimport { calendarScope } from './App';\nimport { retry } from './retry';\n\nexport function useLoadCalendarApi(\n  apiKey: string,\n  clientId: string,\n  user: any\n) {\n  const [haveCalendarApi, setHaveCalendarApi] = useState(false);\n\n  useEffect(() => {\n    async function refresh() {\n      try {\n        console.log('loading calendar for ', user);\n        await initGoogleCalendar(apiKey, clientId);\n        console.log('have calendar');\n        setHaveCalendarApi(true);\n      } catch (ex) {\n        console.log('failed to get calendar');\n      }\n    }\n    if (user && clientId) {\n      refresh();\n    }\n  }, [apiKey, clientId, setHaveCalendarApi, user]);\n\n  return haveCalendarApi;\n}\n/** Try multiple times to load the calendar */\n\nasync function initGoogleCalendar(\n  apiKey: string,\n  clientId: string,\n  retries = 5\n) {\n  function attempt() {\n    return new Promise((resolve, reject) => {\n      gapi.load('client', () => resolve(loadCalendarApi(apiKey, clientId)));\n    });\n  }\n\n  for (let i = 0; i < retries; i++) {\n    try {\n      console.log('loading calendar..');\n      await attempt();\n      return;\n    } catch (ex) {\n      console.error(\n        `Attempt ${i + 1} of ${retries}: failed to load calendar: `,\n        ex\n      );\n      // continue in the loop\n    }\n  }\n}\n/** Try once to load the calendar API with a timeout - rejects if the calendar fails to load */\nfunction loadCalendarApi(apiKey: string, clientId: string, timeout = 2000) {\n  const retryTime = 200;\n  return new Promise(async (resolve, reject) => {\n    try {\n      gapi.client.init({\n        apiKey,\n        clientId,\n        discoveryDocs: [\n          'https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest',\n        ],\n        scope: calendarScope,\n      });\n      // wait up to `timeout` seconds for the calendar to show up\n      await retry(() => !!gapi.client.calendar, 200, timeout / retryTime);\n      console.log('have calendar api');\n      resolve(null);\n    } catch (ex) {\n      console.error('Error loading calendar', ex);\n      reject(ex);\n    }\n  });\n}\n","import { useState, useCallback } from 'react';\nexport function usePersistentState<T>(\n  key: string,\n  value: T\n): [T, (value: T) => void] {\n  const item = window.localStorage.getItem(key);\n  const itemValue = item !== null ? JSON.parse(item) : value;\n  const [state, setState] = useState<T>(itemValue);\n\n  const setStatePersistently = useCallback(\n    (value: T) => {\n      setState(value);\n      window.localStorage.setItem(key, JSON.stringify(value));\n    },\n    [key]\n  );\n  return [state, setStatePersistently];\n}\n","import { useCallback, useEffect, useRef } from 'react';\n\nexport const useTimeout = (\n  callback: () => void,\n\n  // if you create a new callback each render, then previous callback will be cancelled on render.\n  timeout: number = 0\n): (() => void) => {\n  const timeoutIdRef = useRef<NodeJS.Timeout>();\n  const cancel = useCallback(() => {\n    const timeoutId = timeoutIdRef.current;\n    if (timeoutId) {\n      timeoutIdRef.current = undefined;\n      clearTimeout(timeoutId);\n    }\n  }, [timeoutIdRef]);\n\n  useEffect(() => {\n    timeoutIdRef.current = setTimeout(callback, timeout);\n    return cancel;\n  }, [callback, timeout, cancel]);\n\n  return cancel;\n};\n","import classNames from 'classnames';\nimport { format } from 'date-fns';\nimport _ from 'lodash';\nimport React, {\n  Fragment,\n  FunctionComponent,\n  useCallback,\n  useMemo,\n  useState,\n} from 'react';\nimport GoogleLogin, {\n  GoogleLoginResponse,\n  GoogleLoginResponseOffline,\n  GoogleLogout,\n} from 'react-google-login';\nimport ago from 's-ago';\n\nimport styles from './App.module.css';\nimport { useAnimationFrame } from './useAnimationFrame';\nimport { useLoadCalendarApi } from './useLoadCalendarApi';\nimport { usePersistentState } from './usePersistentState';\nimport { useTimeout } from './useTimeout';\n\nconst clientId = process.env.REACT_APP_CLIENT_ID ?? '';\nconst apiKey = 'AIzaSyD01PlE0xERSwpZQauir8ZisF5e7LuNAbo';\nconst ONE_MINUTE = 60;\nconst ONE_HOUR = ONE_MINUTE * 60;\n\nexport const calendarScope =\n  'https://www.googleapis.com/auth/calendar.events.readonly https://www.googleapis.com/auth/calendar.readonly';\n\ninterface CustomEvent extends gapi.client.calendar.Event {\n  happeningNow: boolean;\n  pending: boolean;\n  secondsLeftStart: number;\n  secondsLeftEnd: number;\n  ago: string;\n}\n\nconst App: FunctionComponent = () => {\n  const [gapiToken, setGapiToken] = useState(\n    window.localStorage.getItem('gapi_token')\n  );\n  const [error, setError] = useState<Error | null>();\n  const [user, setUser] = useState<any>();\n  const [\n    calendars,\n    setCalendars,\n  ] = useState<gapi.client.calendar.CalendarList | null>();\n\n  const { loginRenderKey, setGLoginLoaded } = useRetryLogin();\n  const haveCalendarApi = useLoadCalendarApi(apiKey, clientId, user);\n\n  const onSuccess = useCallback(\n    (response: GoogleLoginResponse | GoogleLoginResponseOffline) => {\n      console.log(\n        'onSuccess',\n        'tokenId' in response ? response.tokenId : response\n      );\n      setGLoginLoaded(true);\n      if (!('tokenId' in response)) {\n        return;\n      }\n      console.log('response: ', response);\n      window.localStorage.setItem('gapi_token', response.tokenId);\n      setUser(response.profileObj);\n    },\n    [setGLoginLoaded]\n  );\n\n  const onFailure = useCallback(\n    (response) => {\n      setGLoginLoaded(true);\n      console.log('failure: ', response);\n      setError(response);\n    },\n    [setGLoginLoaded]\n  );\n  const [\n    events,\n    setEvents,\n  ] = usePersistentState<gapi.client.calendar.Events | null>(\n    'current_events',\n    null\n  );\n  const [calendarId, setCalendarId] = usePersistentState<string>(\n    'calendarId',\n    ''\n  );\n\n  const onLogout = useCallback(() => {\n    setGapiToken(null);\n    setUser(null);\n    window.localStorage.removeItem('gapi_token');\n  }, []);\n  const onLoadCalendar = useCallback(async () => {\n    const calendars = await gapi.client.calendar.calendarList.list();\n    setCalendars(calendars.result);\n  }, []);\n\n  const loadEvents = useCallback(\n    async (calendarId: string) => {\n      setCalendarId(calendarId);\n      const calendarEvents = await gapi.client.calendar.events.list(\n        makeCalendarListQuery(calendarId)\n      );\n      setEvents(calendarEvents.result);\n      setCalendars(null);\n    },\n    [setCalendarId, setEvents]\n  );\n\n  const reloadCurrentCalendar = useCallback(() => {\n    if (calendarId) {\n      loadEvents(calendarId);\n    }\n  }, [calendarId, loadEvents]);\n\n  useTimeout(reloadCurrentCalendar, ONE_HOUR);\n\n  const time = useCurrentTime();\n\n  const { current, future } = useMemo(() => {\n    return extractEvents(time, events);\n  }, [events, time]);\n\n  return (\n    <div className={styles.app}>\n      <header className={styles.header}>\n        <h1 className={styles.time}>{time?.toLocaleTimeString()}</h1>\n        {error && (\n          <div>\n            Error:{' '}\n            <pre style={{ fontSize: '12px' }}>{JSON.stringify(error)}</pre>\n          </div>\n        )}\n        {calendars && (\n          <ul>\n            {calendars.items?.map((calendar) => (\n              <li key={calendar.id}>\n                <button onClick={() => loadEvents(calendar.id ?? '')}>\n                  {calendar.summary}\n                </button>\n              </li>\n            ))}\n          </ul>\n        )}\n        {!!current?.length && (\n          <div>\n            <h2 className={styles.timeHeader}>Right now</h2>\n\n            <ul>\n              {current.map((event) => (\n                <EventBanner key={event.id} event={event} />\n              ))}\n            </ul>\n          </div>\n        )}\n        {!!future?.length && (\n          <div>\n            <h2 className={styles.timeHeader}>Coming up</h2>\n            <ul>\n              {future.map((event) => (\n                <EventBanner key={event.id} event={event} />\n              ))}\n            </ul>\n          </div>\n        )}\n        <div>\n          {user && <div>User: {user.name}</div>}\n          <GoogleLogin\n            key={loginRenderKey}\n            clientId={clientId}\n            buttonText=\"Login\"\n            onSuccess={onSuccess}\n            onFailure={onFailure}\n            isSignedIn\n            uxMode=\"redirect\"\n            scope={calendarScope}\n          />\n          {gapiToken && (\n            <GoogleLogout clientId={clientId} onLogoutSuccess={onLogout} />\n          )}\n          <button onClick={onLoadCalendar} disabled={!haveCalendarApi}>\n            Load calendar\n          </button>\n        </div>\n      </header>\n    </div>\n  );\n};\n\nexport default App;\n\nconst loadTime = new Date();\nconst EventBanner: FunctionComponent<{ event: CustomEvent }> = ({ event }) => {\n  const soon = event.secondsLeftStart < ONE_HOUR;\n  const imminent = event.secondsLeftStart < 5 * ONE_MINUTE;\n  const colorClass = classNames(\n    {\n      [styles.now]: event.happeningNow,\n      [styles.soon]: soon && !imminent,\n      [styles.imminent]: imminent,\n    },\n    styles.banner\n  );\n\n  const start = format(new Date(event.start?.dateTime ?? ''), 'h:mm');\n  const left = ago(new Date(event.end?.dateTime ?? ''));\n  return (\n    <li\n      key={event.id}\n      className={colorClass}\n      data-secondsLeft={event.secondsLeftStart}\n      data-minutesLeft={event.secondsLeftStart / 60}\n    >\n      {event.summary} {event.pending ? event.ago : null}\n      {event.pending && (\n        <Fragment>\n          {` @`}&nbsp;{start}\n        </Fragment>\n      )}\n      <div className={styles.note}>\n        {event.happeningNow && ` ending ${left}`}\n      </div>\n    </li>\n  );\n};\n\nfunction extractEvents(time: Date, events: gapi.client.calendar.Events | null) {\n  const now = time.toISOString();\n\n  const futureEvents =\n    events?.items\n      ?.map((event): CustomEvent | null => {\n        const { start, end } = event;\n        // We dont support all-day events yet\n        if (!start?.dateTime) {\n          return null;\n        }\n        const eventStart = new Date(start.dateTime);\n        const startDateTime = eventStart.toISOString();\n        const eventEnd = new Date(end?.dateTime ?? '');\n        const endDateTime = eventEnd.toISOString();\n\n        const ended = now > endDateTime;\n        if (ended || eventStart.getDay() !== time.getDay()) {\n          return null;\n        }\n\n        const happeningNow = startDateTime <= now && now < endDateTime;\n        const pending = !happeningNow ? endDateTime > now : false;\n\n        const secondsLeftStart = Math.floor(\n          (eventStart.valueOf() - time.valueOf()) / 1000\n        );\n        const secondsLeftEnd = Math.floor(\n          (eventEnd.valueOf() - time.valueOf()) / 1000\n        );\n\n        return {\n          ...event,\n          happeningNow,\n          pending,\n          secondsLeftStart,\n          secondsLeftEnd,\n          ago: ago(eventStart),\n        };\n      })\n      .filter(notEmpty) ?? [];\n  const [current, future] = _.partition(\n    futureEvents,\n    (event) => event.happeningNow\n  );\n  // console.log('current = ', current);\n  // console.log('future = ', future);\n  return { current, future: future.slice(0, 3) };\n}\n\nfunction useCurrentTime() {\n  const [time, setTime] = useState<Date>(loadTime);\n  const onFrame = useCallback(() => {\n    setTime(new Date());\n  }, []);\n  useAnimationFrame(1000, onFrame);\n  return time;\n}\n\nfunction makeCalendarListQuery(calendarId: string) {\n  console.log('filtering by ', new Date().toISOString());\n  return {\n    calendarId,\n    timeMin: new Date().toISOString(),\n    showDeleted: false,\n    singleEvents: true,\n    maxResults: 10,\n    orderBy: 'startTime',\n  };\n}\nfunction notEmpty<TValue>(value: TValue | null | undefined): value is TValue {\n  return value !== null && value !== undefined;\n}\n\nfunction useRetryLogin() {\n  const [gLoginLoaded, setGLoginLoaded] = useState(false);\n  const [loginRenderKey, setLoginRenderKey] = useState('start');\n  const setLoginState = useCallback(() => {\n    if (!gLoginLoaded) {\n      setLoginRenderKey(`key-${Math.random()}`);\n    }\n  }, [gLoginLoaded]);\n  useAnimationFrame(gLoginLoaded ? 0 : 3000, setLoginState);\n  return { setGLoginLoaded, loginRenderKey };\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"app\":\"App_app__1kX79\",\"logo\":\"App_logo__1ItuU\",\"time\":\"App_time__Mwxyj\",\"header\":\"App_header__3ZZ1n\",\"link\":\"App_link__TB6Cl\",\"banner\":\"App_banner__29E-O\",\"soon\":\"App_soon__1HASJ\",\"imminent\":\"App_imminent__3j97Z\",\"now\":\"App_now__19jbL\",\"timeHeader\":\"App_timeHeader__3vLT2\",\"note\":\"App_note__3pgJB\",\"App-logo-spin\":\"App_App-logo-spin__1e7sv\"};"],"sourceRoot":""}